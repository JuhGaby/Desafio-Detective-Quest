#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TAMANHO_HASH 10
#define MAX_SUSPEITOS 5
#define MIN_PISTAS_CULPADO 2

// Defini√ß√£o da estrutura da sala
typedef struct Sala {
    char nome[50];
    char pista[100];
    struct Sala *esquerda;
    struct Sala *direita;
} Sala;

// Defini√ß√£o da estrutura para a √°rvore BST de pistas
typedef struct PistaNode {
    char pista[100];
    struct PistaNode *esquerda;
    struct PistaNode *direita;
} PistaNode;

// Defini√ß√£o da estrutura para a tabela hash
typedef struct HashNode {
    char pista[100];
    char suspeito[50];
    struct HashNode *proximo;
} HashNode;

// Defini√ß√£o da estrutura para contagem de suspeitos
typedef struct {
    char nome[50];
    int contagem;
} SuspeitoContagem;

/**
 * Fun√ß√£o: criarSala
 * Prop√≥sito: Cria uma nova sala dinamicamente com nome e pista
 * Par√¢metros: 
 *   - nome: string com o nome da sala
 *   - pista: string com a pista da sala
 * Retorno: Ponteiro para a sala criada
 */
Sala* criarSala(const char* nome, const char* pista) {
    Sala* novaSala = (Sala*)malloc(sizeof(Sala));
    if (novaSala == NULL) {
        printf("Erro: Mem√≥ria insuficiente!\n");
        exit(1);
    }
    
    strcpy(novaSala->nome, nome);
    strcpy(novaSala->pista, pista);
    novaSala->esquerda = NULL;
    novaSala->direita = NULL;
    
    return novaSala;
}

/**
 * Fun√ß√£o: criarNoPista
 * Prop√≥sito: Cria um novo n√≥ para a √°rvore BST de pistas
 * Par√¢metros: pista - string com o conte√∫do da pista
 * Retorno: Ponteiro para o n√≥ de pista criado
 */
PistaNode* criarNoPista(const char* pista) {
    PistaNode* novoNo = (PistaNode*)malloc(sizeof(PistaNode));
    if (novoNo == NULL) {
        printf("Erro: Mem√≥ria insuficiente!\n");
        exit(1);
    }
    
    strcpy(novoNo->pista, pista);
    novoNo->esquerda = NULL;
    novoNo->direita = NULL;
    
    return novoNo;
}

/**
 * Fun√ß√£o: inserirPista
 * Prop√≥sito: Insere uma nova pista na √°rvore BST em ordem alfab√©tica
 * Par√¢metros: 
 *   - raiz: ponteiro para a raiz da √°rvore de pistas
 *   - pista: string com a pista a ser inserida
 * Retorno: Ponteiro para a raiz atualizada da √°rvore
 */
PistaNode* inserirPista(PistaNode* raiz, const char* pista) {
    if (raiz == NULL) {
        return criarNoPista(pista);
    }
    
    int comparacao = strcmp(pista, raiz->pista);
    
    if (comparacao < 0) {
        raiz->esquerda = inserirPista(raiz->esquerda, pista);
    } else if (comparacao > 0) {
        raiz->direita = inserirPista(raiz->direita, pista);
    }
    
    return raiz;
}

/**
 * Fun√ß√£o: funcaoHash
 * Prop√≥sito: Calcula o √≠ndice hash para uma pista
 * Par√¢metros: pista - string com a pista
 * Retorno: √çndice hash calculado
 */
int funcaoHash(const char* pista) {
    int hash = 0;
    for (int i = 0; pista[i] != '\0'; i++) {
        hash = (hash * 31 + pista[i]) % TAMANHO_HASH;
    }
    return hash;
}

/**
 * Fun√ß√£o: criarNoHash
 * Prop√≥sito: Cria um novo n√≥ para a tabela hash
 * Par√¢metros: 
 *   - pista: string com a pista
 *   - suspeito: string com o nome do suspeito
 * Retorno: Ponteiro para o n√≥ hash criado
 */
HashNode* criarNoHash(const char* pista, const char* suspeito) {
    HashNode* novoNo = (HashNode*)malloc(sizeof(HashNode));
    if (novoNo == NULL) {
        printf("Erro: Mem√≥ria insuficiente!\n");
        exit(1);
    }
    
    strcpy(novoNo->pista, pista);
    strcpy(novoNo->suspeito, suspeito);
    novoNo->proximo = NULL;
    
    return novoNo;
}

/**
 * Fun√ß√£o: inserirNaHash
 * Prop√≥sito: Insere uma associa√ß√£o pista-suspeito na tabela hash
 * Par√¢metros: 
 *   - tabela: array da tabela hash
 *   - pista: string com a pista
 *   - suspeito: string com o nome do suspeito
 */
void inserirNaHash(HashNode* tabela[], const char* pista, const char* suspeito) {
    int indice = funcaoHash(pista);
    
    HashNode* novoNo = criarNoHash(pista, suspeito);
    
    // Inser√ß√£o no in√≠cio da lista encadeada
    if (tabela[indice] != NULL) {
        novoNo->proximo = tabela[indice];
    }
    tabela[indice] = novoNo;
}

/**
 * Fun√ß√£o: encontrarSuspeito
 * Prop√≥sito: Consulta o suspeito correspondente a uma pista na tabela hash
 * Par√¢metros: 
 *   - tabela: array da tabela hash
 *   - pista: string com a pista a ser pesquisada
 *   - suspeito: buffer para armazenar o nome do suspeito encontrado
 * Retorno: 1 se encontrou, 0 se n√£o encontrou
 */
int encontrarSuspeito(HashNode* tabela[], const char* pista, char* suspeito) {
    int indice = funcaoHash(pista);
    HashNode* atual = tabela[indice];
    
    while (atual != NULL) {
        if (strcmp(atual->pista, pista) == 0) {
            strcpy(suspeito, atual->suspeito);
            return 1;
        }
        atual = atual->proximo;
    }
    
    return 0;
}

/**
 * Fun√ß√£o: exibirPistas
 * Prop√≥sito: Exibe todas as pistas coletadas em ordem alfab√©tica
 * Par√¢metros: 
 *   - raiz: ponteiro para a raiz da √°rvore de pistas
 *   - tabela: tabela hash para mostrar os suspeitos associados
 */
void exibirPistas(PistaNode* raiz, HashNode* tabela[]) {
    if (raiz != NULL) {
        exibirPistas(raiz->esquerda, tabela);
        
        char suspeito[50];
        if (encontrarSuspeito(tabela, raiz->pista, suspeito)) {
            printf("‚Ä¢ %s ‚Üí Aponta para: %s\n", raiz->pista, suspeito);
        } else {
            printf("‚Ä¢ %s ‚Üí Suspeito desconhecido\n", raiz->pista);
        }
        
        exibirPistas(raiz->direita, tabela);
    }
}

/**
 * Fun√ß√£o: contarPistasPorSuspeito
 * Prop√≥sito: Conta quantas pistas apontam para cada suspeito
 * Par√¢metros: 
 *   - raiz: ponteiro para a raiz da √°rvore de pistas
 *   - tabela: tabela hash com as associa√ß√µes
 *   - suspeitos: array de contagem de suspeitos
 *   - numSuspeitos: n√∫mero total de suspeitos
 */
void contarPistasPorSuspeito(PistaNode* raiz, HashNode* tabela[], 
                            SuspeitoContagem suspeitos[], int numSuspeitos) {
    if (raiz != NULL) {
        contarPistasPorSuspeito(raiz->esquerda, tabela, suspeitos, numSuspeitos);
        
        char suspeito[50];
        if (encontrarSuspeito(tabela, raiz->pista, suspeito)) {
            for (int i = 0; i < numSuspeitos; i++) {
                if (strcmp(suspeitos[i].nome, suspeito) == 0) {
                    suspeitos[i].contagem++;
                    break;
                }
            }
        }
        
        contarPistasPorSuspeito(raiz->direita, tabela, suspeitos, numSuspeitos);
    }
}

/**
 * Fun√ß√£o: explorarSalas
 * Prop√≥sito: Navega pela √°rvore e coleta pistas
 * Par√¢metros: 
 *   - salaAtual: ponteiro para a sala atual
 *   - arvorePistas: ponteiro para o ponteiro da √°rvore de pistas
 */
void explorarSalas(Sala* salaAtual, PistaNode** arvorePistas) {
    char opcao;
    
    printf("\n=== DETECTIVE QUEST - SISTEMA DE INVESTIGA√á√ÉO ===\n");
    printf("üìç Voc√™ est√° na: %s\n", salaAtual->nome);
    
    // Verifica se h√° pista nesta sala
    if (strlen(salaAtual->pista) > 0) {
        printf("\nüîç PISTA ENCONTRADA: \"%s\"\n", salaAtual->pista);
        
        // Adiciona a pista √† √°rvore BST
        *arvorePistas = inserirPista(*arvorePistas, salaAtual->pista);
        printf("‚úÖ Pista registrada no caderno de investiga√ß√£o!\n");
        
        // Marca a pista como coletada
        strcpy(salaAtual->pista, "");
    }
    
    // Mostra op√ß√µes de navega√ß√£o
    printf("\nüõ£Ô∏è  Op√ß√µes de explora√ß√£o:\n");
    if (salaAtual->esquerda != NULL) {
        printf("[e] Ir para a ESQUERDA ‚Üí %s\n", salaAtual->esquerda->nome);
    }
    if (salaAtual->direita != NULL) {
        printf("[d] Ir para a DIREITA ‚Üí %s\n", salaAtual->direita->nome);
    }
    printf("[s] SAIR da explora√ß√£o e fazer acusa√ß√£o\n");
    
    // Loop para obter uma op√ß√£o v√°lida
    while (1) {
        printf("\nüéØ Escolha uma op√ß√£o: ");
        scanf(" %c", &opcao);
        
        switch (opcao) {
            case 'e':
            case 'E':
                if (salaAtual->esquerda != NULL) {
                    explorarSalas(salaAtual->esquerda, arvorePistas);
                    return;
                } else {
                    printf("‚ùå N√£o h√° caminho √† esquerda!\n");
                }
                break;
                
            case 'd':
            case 'D':
                if (salaAtual->direita != NULL) {
                    explorarSalas(salaAtual->direita, arvorePistas);
                    return;
                } else {
                    printf("‚ùå N√£o h√° caminho √† direita!\n");
                }
                break;
                
            case 's':
            case 'S':
                printf("üö™ Saindo da explora√ß√£o...\n");
                return;
                
            default:
                printf("‚ùå Op√ß√£o inv√°lida! Use 'e', 'd' ou 's'.\n");
                break;
        }
    }
}

/**
 * Fun√ß√£o: verificarSuspeitoFinal
 * Prop√≥sito: Conduz √† fase de julgamento final e verifica a acusa√ß√£o
 * Par√¢metros: 
 *   - arvorePistas: √°rvore de pistas coletadas
 *   - tabela: tabela hash com associa√ß√µes pista-suspeito
 */
void verificarSuspeitoFinal(PistaNode* arvorePistas, HashNode* tabela[]) {
    char suspeitos[][50] = {
        "Carlos", "Ana", "Roberto", "Mariana", "Pedro"
    };
    int numSuspeitos = 5;
    
    SuspeitoContagem contagem[MAX_SUSPEITOS];
    for (int i = 0; i < numSuspeitos; i++) {
        strcpy(contagem[i].nome, suspeitos[i]);
        contagem[i].contagem = 0;
    }
    
    // Conta pistas por suspeito
    contarPistasPorSuspeito(arvorePistas, tabela, contagem, numSuspeitos);
    
    printf("\n=== FASE DE ACUSA√á√ÉO ===\n");
    printf("üìä Resumo das pistas por suspeito:\n");
    for (int i = 0; i < numSuspeitos; i++) {
        printf("   %s: %d pista(s)\n", contagem[i].nome, contagem[i].contagem);
    }
    
    printf("\nüé≠ Lista de Suspeitos:\n");
    for (int i = 0; i < numSuspeitos; i++) {
        printf("%d. %s\n", i + 1, suspeitos[i]);
    }
    
    int acusacao;
    printf("\nüîé Quem √© o culpado? (Digite o n√∫mero): ");
    scanf("%d", &acusacao);
    
    if (acusacao < 1 || acusacao > numSuspeitos) {
        printf("‚ùå Acusa√ß√£o inv√°lida! O caso ficar√° sem solu√ß√£o.\n");
        return;
    }
    
    char* culpadoAcusado = suspeitos[acusacao - 1];
    int pistasCulpado = contagem[acusacao - 1].contagem;
    
    printf("\n=== VERDICT FINAL ===\n");
    printf("üéØ Voc√™ acusou: %s\n", culpadoAcusado);
    printf("üìà Pistas que apontam para %s: %d\n", culpadoAcusado, pistasCulpado);
    
    if (pistasCulpado >= MIN_PISTAS_CULPADO) {
        printf("‚úÖ PARAB√âNS! A acusa√ß√£o est√° correta!\n");
        printf("   Com %d pistas, temos evid√™ncias suficientes para condenar %s!\n", 
               pistasCulpado, culpadoAcusado);
    } else {
        printf("‚ùå FALHA NA INVESTIGA√á√ÉO!\n");
        printf("   Apenas %d pista(s) apontam para %s. Necess√°rias pelo menos %d.\n", 
               pistasCulpado, culpadoAcusado, MIN_PISTAS_CULPADO);
        printf("   O verdadeiro culpado escapou da justi√ßa!\n");
    }
}

/**
 * Fun√ß√£o: liberarArvoreSalas
 * Prop√≥sito: Libera mem√≥ria da √°rvore de salas
 */
void liberarArvoreSalas(Sala* raiz) {
    if (raiz != NULL) {
        liberarArvoreSalas(raiz->esquerda);
        liberarArvoreSalas(raiz->direita);
        free(raiz);
    }
}

/**
 * Fun√ß√£o: liberarArvorePistas
 * Prop√≥sito: Libera mem√≥ria da √°rvore de pistas
 */
void liberarArvorePistas(PistaNode* raiz) {
    if (raiz != NULL) {
        liberarArvorePistas(raiz->esquerda);
        liberarArvorePistas(raiz->direita);
        free(raiz);
    }
}

/**
 * Fun√ß√£o: liberarTabelaHash
 * Prop√≥sito: Libera mem√≥ria da tabela hash
 */
void liberarTabelaHash(HashNode* tabela[]) {
    for (int i = 0; i < TAMANHO_HASH; i++) {
        HashNode* atual = tabela[i];
        while (atual != NULL) {
            HashNode* proximo = atual->proximo;
            free(atual);
            atual = proximo;
        }
    }
}

/**
 * Fun√ß√£o: main
 * Prop√≥sito: Monta o mapa, inicializa sistemas e inicia o jogo
 */
int main() {
    printf("=== DETECTIVE QUEST - CASO: O MIST√âRIO DA MANS√ÉO ===\n");
    printf("üéÆ Inicializando sistemas de investiga√ß√£o...\n");
    
    // Inicializa tabela hash
    HashNode* tabelaHash[TAMANHO_HASH] = {NULL};
    
    // Cria√ß√£o do mapa da mans√£o com pistas
    Sala* hallEntrada = criarSala("Hall de Entrada", "Porta principal com arrombamento sofisticado");
    Sala* salaEstar = criarSala("Sala de Estar", "Copo de vinho tinto com batom");
    Sala* biblioteca = criarSala("Biblioteca", "Livro sobre venenos com p√°gina 42 marcada");
    Sala* escritorio = criarSala("Escrit√≥rio Secreto", "Carta de amea√ßa datilografada");
    Sala* cozinha = criarSala("Cozinha", "Faca de chef desaparecida do bloco");
    Sala* jardim = criarSala("Jardim de Inverno", "Pegadas de lama tamanho 42");
    Sala* salaJogos = criarSala("Sala de Jogos", "Rel√≥gio de parede parado √†s 21:47");
    Sala* quarto = criarSala("Quarto Principal", "Perfume franc√™s na penteadeira");
    
    // Monta a estrutura da √°rvore
    hallEntrada->esquerda = salaEstar;
    hallEntrada->direita = cozinha;
    salaEstar->esquerda = biblioteca;
    salaEstar->direita = escritorio;
    cozinha->esquerda = jardim;
    cozinha->direita = salaJogos;
    biblioteca->direita = quarto;
    
    // Popula a tabela hash com associa√ß√µes pista-suspeito
    inserirNaHash(tabelaHash, "Porta principal com arrombamento sofisticado", "Carlos");
    inserirNaHash(tabelaHash, "Copo de vinho tinto com batom", "Ana");
    inserirNaHash(tabelaHash, "Livro sobre venenos com p√°gina 42 marcada", "Roberto");
    inserirNaHash(tabelaHash, "Carta de amea√ßa datilografada", "Mariana");
    inserirNaHash(tabelaHash, "Faca de chef desaparecida do bloco", "Carlos");
    inserirNaHash(tabelaHash, "Pegadas de lama tamanho 42", "Pedro");
    inserirNaHash(tabelaHash, "Rel√≥gio de parede parado √†s 21:47", "Ana");
    inserirNaHash(tabelaHash, "Perfume franc√™s na penteadeira", "Mariana");
    
    // Inicializa √°rvore de pistas
    PistaNode* arvorePistas = NULL;
    
    printf("‚úÖ Sistemas carregados com sucesso!\n");
    printf("üîç Explore a mans√£o, colete pistas e descubra o culpado!\n");
    printf("   Voc√™ precisa de pelo menos %d pistas contra o culpado para ganhar.\n\n", MIN_PISTAS_CULPADO);
    
    // Inicia explora√ß√£o
    explorarSalas(hallEntrada, &arvorePistas);
    
    // Mostra pistas coletadas
    printf("\n=== CADERNO DE INVESTIGA√á√ÉO ===\n");
    printf("üìñ Pistas coletadas e suspeitos associados:\n");
    if (arvorePistas == NULL) {
        printf("   Nenhuma pista foi coletada.\n");
    } else {
        exibirPistas(arvorePistas, tabelaHash);
    }
    
    // Fase de acusa√ß√£o final
    verificarSuspeitoFinal(arvorePistas, tabelaHash);
    
    // Libera mem√≥ria
    liberarArvoreSalas(hallEntrada);
    liberarArvorePistas(arvorePistas);
    liberarTabelaHash(tabelaHash);
    
    printf("\n=== FIM DO CASO ===\n");
    printf("Obrigado por jogar Detective Quest!\n");
    
    return 0;
}